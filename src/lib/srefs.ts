import path from 'path';
import type { ProcessedSref, ProcessedImage, SrefMetadata, SrefImage } from './types';
import { getImage } from 'astro:assets';
import { getSrefCount as getCount, getAllSrefMetadata, getSrefMetadataById } from './sref-data';

const DATA_DIR = path.join(process.cwd(), 'src', 'data', 'srefs');

export { getSrefCount } from './sref-data';

export async function getAllSrefs(): Promise<ProcessedSref[]> {
  const metadataList = await getAllSrefMetadata();
  const srefs = await Promise.all(
    metadataList.map(async (metadata) => {
      try {
        return await processMetadata(metadata);
      } catch (error) {
        console.error(`Error processing sref ${metadata.id}:`, error);
        return null;
      }
    })
  );
  
  return srefs.filter((sref): sref is ProcessedSref => sref !== null);
}

export async function getSrefById(id: string): Promise<ProcessedSref | null> {
  const metadata = await getSrefMetadataById(id);
  if (!metadata) {
    return null;
  }
  
  return processMetadata(metadata);
}

async function processImageToProcessedImage(img: SrefImage, dirName: string, imagesDir: string): Promise<ProcessedImage> {
  const localFilePath = path.join(imagesDir, img.filename);
  const dimensions = await getImageDimensions(localFilePath);
  
  // Create relative path from src directory for Astro's getImage()
  const relativePath = `./data/srefs/${dirName}/images/${img.filename}`;
  
  return {
    ...img,
    url: '', // URL will be generated by getImage() when needed
    filePath: relativePath, // Relative path for Astro
    width: dimensions.width,
    height: dimensions.height,
    aspectRatio: dimensions.width / dimensions.height,
  };
}

async function processMetadata(metadata: SrefMetadata): Promise<ProcessedSref> {
  const dirName = `sref-${metadata.id}`;
  const imagesDir = path.join(DATA_DIR, dirName, 'images');
  
  const processedImages: ProcessedImage[] = await Promise.all(
    (metadata.images || []).map(async (img) => 
      processImageToProcessedImage(img, dirName, imagesDir)
    )
  );
  
  const coverImage = processedImages.find(img => img.filename === metadata.cover_image) || processedImages[0];
  
  return {
    ...metadata,
    path: `${import.meta.env.BASE_URL.endsWith('/') ? import.meta.env.BASE_URL : import.meta.env.BASE_URL + '/'}sref/${metadata.id}`,
    coverImageUrl: '', // URL will be generated by getImage() when needed
    coverImagePath: coverImage?.filePath,
    processedImages,
  };
}

async function getImageDimensions(imagePath: string): Promise<{ width: number; height: number }> {
  try {
    // Check if file exists first
    const fs = await import('fs/promises');
    await fs.access(imagePath);
    
    const sharp = await import('sharp');
    const metadata = await sharp.default(imagePath).metadata();
    
    return {
      width: metadata.width || 100,
      height: metadata.height || 100,
    };
  } catch (error) {
    // Silently handle missing images in CI environment
    if (process.env.CI) {
      return { width: 1024, height: 1024 }; // Default dimensions for CI
    }
    console.warn(`Warning: Image not found or invalid: ${imagePath}`);
    return { width: 1024, height: 1024 }; // Default dimensions
  }
}

export function buildSearchIndex(srefs: ProcessedSref[]) {
  return srefs.map(sref => ({
    id: sref.id,
    title: sref.title,
    description: sref.description || '',
    tags: sref.tags,
    searchText: `${sref.id} ${sref.title} ${sref.description || ''} ${sref.tags.join(' ')}`.toLowerCase(),
    coverImageUrl: sref.coverImageUrl,
    path: sref.path,
  }));
}